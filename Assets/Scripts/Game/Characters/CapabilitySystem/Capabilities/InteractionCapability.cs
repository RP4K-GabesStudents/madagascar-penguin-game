using Game.Characters.Capabilities;
using Interfaces;
using Inventory;
using Managers;
using UnityEngine;

namespace Game.Characters.CapabilitySystem.Capabilities
{
    public class InteractionCapability : BaseCapability, IInputSubscriber
    {
        private IInteractable _interactable;

        private InteractionCapabilityStats _stats;

        
        protected override void OnBound()
        {
            base.OnBound();
                                           
            _stats = genericStats as InteractionCapabilityStats;
            if (_stats == null) { Debug.LogAssertion($"Wrong stats assigned to object {name},expected {typeof(InteractionCapabilityStats)}, but retrieved {genericStats.GetType()}.", gameObject); }
        }
        
        
        public override bool CanExecute()
        {
            return _interactable != null;
        }

        protected override void Execute()
        {
            if (_interactable is Item i)
            {
                if (owner.inventory.HeyIPickedSomethingUp(i.ItemStats))
                {
                    owner.animator.SetTrigger(StaticUtilities.InteractAnimID);
                    Debug.LogWarning("success");
                    _interactable.OnInteract(owner);
                    if(!_interactable.CanHover()) HandleHovering(null);
                }
                else
                {
                    Debug.LogWarning("do a barrel roll {Failed to pick up item}");
                }
            }
            else
            {
                owner.animator.SetTrigger(StaticUtilities.InteractAnimID);
                _interactable.OnInteract(owner);
                if(!_interactable.CanHover()) HandleHovering(null);
            }
        }

        private void LateUpdate()
        {
            CheckForInteractable();
        }

        private void CheckForInteractable()
        {

            Vector3 origin = owner.Head.position;
            Vector3 direction = owner.Head.forward;

            bool byPass = Physics.Raycast(origin, direction, out var byPassed, _stats.InteractionRadius, _stats.CombinedLayers);
            if (byPass)
            {
                bool directHit = ((1 << byPassed.collider.gameObject.layer) & _stats.InteractionLayers) != 0;
                if (directHit)
                {
                    Rigidbody rb = byPassed.rigidbody;
                    if (rb && rb.TryGetComponent(out IInteractable interactable))
                    {
                        HandleHovering(interactable);
                        return;
                    }
                }
                else 
                {
                    bool interactHit = Physics.SphereCast(origin, _stats.InteractionRadius, direction, out RaycastHit hitInfo, _stats.InteractionDistance, _stats.InteractionLayers);
                    if (interactHit)
                    {
                        Debug.DrawLine(origin, hitInfo.point, Color.green, 0.1f);
                        Rigidbody rb = hitInfo.rigidbody;
                        if (rb && rb.TryGetComponent(out IInteractable interactable))
                        {
                            HandleHovering(interactable);
                            return;
                        }
                    }
                }
            }
            HandleHovering(null);
        }


        private void OnDrawGizmosSelected()
        {
            _stats ??= genericStats as InteractionCapabilityStats;
            if (_stats == null) return;
            
            owner ??= transform.root.GetComponent<GenericCharacter>();
            if (owner == null) return;
            
            // GENERATED BY CHAT GPT
            Vector3 origin = owner.Head.position;
            Vector3 direction = owner.Head.forward;

            // Raycast for bypass
            bool byPass = Physics.Raycast(origin, direction, out RaycastHit byPassed, _stats.InteractionRadius, _stats.CombinedLayers);
            if (byPass)
            {
                // Draw bypass ray
                Gizmos.color = Color.yellow;
                Gizmos.DrawLine(origin, byPassed.point);
                Gizmos.DrawWireSphere(byPassed.point, 0.05f);

                // Check for direct hit
                bool directHit = ((1 << byPassed.collider.gameObject.layer) & _stats.InteractionLayers) != 0;
                if (directHit)
                {
                    Gizmos.color = Color.red;
                    Gizmos.DrawWireSphere(byPassed.point, 0.15f); // Indicate direct hit
                    return;
                }
                // SphereCast fallback
                bool interactHit = Physics.SphereCast(origin, _stats.InteractionRadius, direction, out RaycastHit hitInfo, _stats.InteractionDistance, _stats.InteractionLayers);
                if (interactHit)
                {
                    Gizmos.color = Color.green;
                    Gizmos.DrawLine(origin, hitInfo.point);
                    Gizmos.DrawWireSphere(hitInfo.point, _stats.InteractionRadius);
                    return;
                }

                // Draw max reach for failed spherecast
                Vector3 end = origin + direction * _stats.InteractionDistance;
                Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
                Gizmos.DrawWireSphere(end, _stats.InteractionRadius);
                Gizmos.DrawLine(origin, end);
            }
            else
            {
                // Nothing hit: show max reach ray
                Vector3 end = origin + direction * _stats.InteractionRadius;
                Gizmos.color = Color.gray;
                Gizmos.DrawLine(origin, end);
            }
        }

        private void HandleHovering(IInteractable interactable)
        {
            if (_interactable == interactable) return;
            if ((Behaviour)_interactable) _interactable.OnHoverEndDriver();
            _interactable?.OnHoverEndDriver();
            if(interactable != null && interactable.CanHover()) interactable.OnHoverDriver();
            _interactable = interactable;
        }

        public void BindControls(GameControls controls)
        {
            controls.Player.Interact.performed += _ => TryExecute();
        }
    }
}